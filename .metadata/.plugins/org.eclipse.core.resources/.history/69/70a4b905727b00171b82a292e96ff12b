object queens {
  def nqueens(n: Int): Set[List[Int]] = {
  	def placeQueens(k: Int): Set[List[Int]] = {
  		if (k == 0) Set(List())
  		else
  			for {
  				queens <- placeQueens(k-1)
  				col <- 0 until n
  				if(isSafe(col, queens))
  			} yield col :: queens
  	}
  	placeQueens(n)
  }                                               //> nqueens: (n: Int)Set[List[Int]]
  
  def isSafe(col: Int, queens: List[Int]): Boolean = {
    val row = queens.length
  	// 1st check columns
  	if (queens contains col) false
  	// 2nd check all diagonals
  	else {
  		val q =  (0 until queens.length) zip queens.reverse
  		!(diags(row, col, 4) exists (x => q.toSet contains x))
  		}
  }                                               //> isSafe: (col: Int, queens: List[Int])Boolean
  
  def diags(row: Int, col: Int, n: Int): IndexedSeq[(Int, Int)] =
  	for {
  	c <- 0 until n
  	r <- 0 until n
  	if (c - col == r - row) || (c + col == r + row)
  	} yield (c, r)                            //> diags: (row: Int, col: Int, n: Int)IndexedSeq[(Int, Int)]
  	
  	
  	nqueens(4)                                //> res0: Set[List[Int]] = Set(List(0, 3, 1, 2), List(1, 2, 0, 3), List(0, 2, 3,
                                                  //|  1), List(2, 0, 1, 3))
}